#!/bin/env python3

import argparse
import json
import pymysql
from google.oauth2 import service_account
from google.cloud import storage
import os
import requests

###############################################################################################################
#
#  ██╗   ██╗ █████╗ ██████╗ ██╗ █████╗ ██████╗ ██╗     ███████╗███████╗
#  ██║   ██║██╔══██╗██╔══██╗██║██╔══██╗██╔══██╗██║     ██╔════╝██╔════╝
#  ██║   ██║███████║██████╔╝██║███████║██████╔╝██║     █████╗  ███████╗
#  ╚██╗ ██╔╝██╔══██║██╔══██╗██║██╔══██║██╔══██╗██║     ██╔══╝  ╚════██║
#   ╚████╔╝ ██║  ██║██║  ██║██║██║  ██║██████╔╝███████╗███████╗███████║
#    ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝╚══════╝
#
###############################################################################################################

VERBOSE = True  # This is a constant
webhooks = []  # placeholder for webhooks
bucket_name = "canonn-downloads"  # should probably use a config file for this
store = None  # place holder for the storage location.


###############################################################################################################
#
#    ██████╗██╗      █████╗ ███████╗███████╗███████╗███████╗
#   ██╔════╝██║     ██╔══██╗██╔════╝██╔════╝██╔════╝██╔════╝
#   ██║     ██║     ███████║███████╗███████╗█████╗  ███████╗
#   ██║     ██║     ██╔══██║╚════██║╚════██║██╔══╝  ╚════██║
#   ╚██████╗███████╗██║  ██║███████║███████║███████╗███████║
#    ╚═════╝╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚══════╝
#
###############################################################################################################


# this is a helper class
# Instead of using variable.get("key") or get["key"] you can just user variable.key
class RowObject:
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)


###############################################################################################################
#
#  ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
#  ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
#  █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
#  ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
#  ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
#  ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
#
###############################################################################################################


"""                                   __         __      __        __                  
    _________  ____  ____  ___  _____/ /_   ____/ /___ _/ /_____ _/ /_  ____ _________ 
   / ___/ __ \/ __ \/ __ \/ _ \/ ___/ __/  / __  / __ `/ __/ __ `/ __ \/ __ `/ ___/ _ \
  / /__/ /_/ / / / / / / /  __/ /__/ /_   / /_/ / /_/ / /_/ /_/ / /_/ / /_/ (__  )  __/
  \___/\____/_/ /_/_/ /_/\___/\___/\__/   \__,_/\__,_/\__/\__,_/_.___/\__,_/____/\___/  

"""


def connect_database(database_secrets_file):
    global mysql_conn  # Declare `mysql_conn` as a global variable
    print("Database Secrets File:", database_secrets_file)

    # Open the JSON file containing database secrets
    with open(database_secrets_file) as json_file:
        secret = json.load(json_file)  # Load the JSON data into a dictionary

        # Establish a connection to the MySQL database
        mysql_conn = pymysql.connect(
            host=secret.get("DB_HOST"),  # Get the host from secrets
            user=secret.get("DB_USER"),  # Get the username from secrets
            password=secret.get("DB_PASSWORD"),  # Get the password from secrets
            db=secret.get("DB_NAME"),  # Get the database name from secrets
            port=int(
                secret.get("DB_PORT", 3306)
            ),  # Get the port from secrets, default to 3306 if not provided
            charset="utf8",  # Set the character set to UTF-8,
            cursorclass=pymysql.cursors.DictCursor,
        )
        return mysql_conn


"""                                 __          __                            
  _________  ____  ____  ___  _____/ /_   _____/ /_____  _________ _____ ____ 
 / ___/ __ \/ __ \/ __ \/ _ \/ ___/ __/  / ___/ __/ __ \/ ___/ __ `/ __ `/ _ \
/ /__/ /_/ / / / / / / /  __/ /__/ /_   (__  ) /_/ /_/ / /  / /_/ / /_/ /  __/
\___/\____/_/ /_/_/ /_/\___/\___/\__/  /____/\__/\____/_/   \__,_/\__, /\___/ 
                                                                 /____/       


This fetches the bucket object so that it can be used to store files on the google drive

"""


def connect_storage(storage_secrets_file):
    global bucket_name

    storage_secrets = service_account.Credentials.from_service_account_file(
        storage_secrets_file
    )
    client = storage.Client(credentials=storage_secrets)
    bucket = client.get_bucket(bucket_name)
    return bucket


"""
    __                __                 __    __                __       
   / /___  ____ _____/ /  _      _____  / /_  / /_  ____  ____  / /_______
  / / __ \/ __ `/ __  /  | | /| / / _ \/ __ \/ __ \/ __ \/ __ \/ //_/ ___/
 / / /_/ / /_/ / /_/ /   | |/ |/ /  __/ /_/ / / / / /_/ / /_/ / ,< (__  ) 
/_/\____/\__,_/\__,_/    |__/|__/\___/_.___/_/ /_/\____/\____/_/|_/____/  


This function will load the discord_secrets file so that we can use it 
to send messages to one or more webhooks

"""


def load_webhooks(discord_secrets_file):
    print("Discord Secrets File:", discord_secrets_file)
    try:
        with open(discord_secrets_file, "r") as file:
            webhooks = json.load(file)
            return webhooks
    except FileNotFoundError:
        print("File not found.")
        return []
    except json.JSONDecodeError:
        print("Error decoding JSON.")
        return []


"""                     __       ___                          __
   ________  ____  ____/ /  ____/ (_)_____________  _________/ /
  / ___/ _ \/ __ \/ __  /  / __  / / ___/ ___/ __ \/ ___/ __  / 
 (__  )  __/ / / / /_/ /  / /_/ / (__  ) /__/ /_/ / /  / /_/ /  
/____/\___/_/ /_/\__,_/   \__,_/_/____/\___/\____/_/   \__,_/   

"""


def send_discord(message, verbosity=False):
    global webhooks

    payload = {}
    payload["content"] = message

    # loop through the webhooks and send discord messages
    for webhook in webhooks:
        # only send verbose messages
        if webhook.get("verbose") or verbosity:
            r = requests.post(
                webhook.get("webhook"),
                data=json.dumps(payload),
                headers={"Content-Type": "application/json"},
            )
            print(message)


"""
               __                __              __            
  __  ______  / /___  ____ _____/ /  ___  ____  / /________  __
 / / / / __ \/ / __ \/ __ `/ __  /  / _ \/ __ \/ __/ ___/ / / /
/ /_/ / /_/ / / /_/ / /_/ / /_/ /  /  __/ / / / /_/ /  / /_/ / 
\__,_/ .___/_/\____/\__,_/\__,_/   \___/_/ /_/\__/_/   \__, /  
    /_/                                               /____/  

This uploads a file to google cloud storage and makes it publicly accessible
    
"""


def upload_entry(cnr, rowcount):
    global store

    """Uploads a file to Google Cloud Storage."""
    blob = store.blob(f"dumpr/{cnr.hud_category}/{cnr.entryid}.csv")
    # Upload the file
    blob.upload_from_filename(os.path.join("dumps", f"{cnr.entryid}.csv"))
    blob.make_public()
    send_discord(
        f"Uploaded {cnr.english_name} [{cnr.entryid}.csv](<https://storage.googleapis.com/canonn-downloads/dumpr/{cnr.hud_category}/{cnr.entryid}.csv>) ({rowcount:,} rows)"
    )


"""
      ____ ____  / /_   _________  ____/ /__  _  __   / (_)____/ /_
     / __ `/ _ \/ __/  / ___/ __ \/ __  / _ \| |/_/  / / / ___/ __/
    / /_/ /  __/ /_   / /__/ /_/ / /_/ /  __/>  <   / / (__  ) /_  
    \__, /\___/\__/   \___/\____/\__,_/\___/_/|_|  /_/_/____/\__/  
   /____/                                                          

This function will get a sorted list of codex entries from the database so they can be used
later to fetch each codex item. The sorted list means we don't need to sort the 
bigger table (codex_systems) and this speeds up the whole process and reduces the strain
on the database.
   
"""


def get_codex_list(db, store, webhooks, keywords):
    cursor = db.cursor()
    where = ""
    if keywords is not None:
        where = "where english_name like %s"
    sqltext = f"select entryid,hud_category,english_name from codex_name_ref cnr {where} order by hud_category,entryid"
    if keywords is not None:
        cursor.execute(sqltext, ("%" + keywords + "%"))
    else:
        cursor.execute(sqltext)
    rows = cursor.fetchall()
    cursor.close()
    return rows


"""                                                         __         
    ____  _________  ________  __________   _________  ____/ /__  _  __
   / __ \/ ___/ __ \/ ___/ _ \/ ___/ ___/  / ___/ __ \/ __  / _ \| |/_/
  / /_/ / /  / /_/ / /__/  __(__  |__  )  / /__/ /_/ / /_/ /  __/>  <  
 / .___/_/   \____/\___/\___/____/____/   \___/\____/\__,_/\___/_/|_|  
/_/                                                                    

"""


def process_codex(db, entry):
    cnr = RowObject(**entry)
    rowcount = 0
    try:
        cursor = db.cursor()
        sqltext = """
            select c.system,x,y,z from codex_systems c 
            where entryid = %s
        """
        cursor.execute(sqltext, (cnr.entryid))

        file = open(os.path.join("dumps", f"{cnr.entryid}.csv"), "w")

        while True:
            rows = cursor.fetchmany(1000)
            if not rows:
                break
            # Processing the fetched rows
            for row_dict in rows:
                row = RowObject(**row_dict)
                rowcount += 1
                file.write(f"{row.system},{row.x},{row.y},{row.z},{cnr.entryid}\n")

        # Closing cursor and connection
        cursor.close()
        file.close()

        if rowcount > 0:
            upload_entry(cnr, rowcount)
        else:
            send_discord(f"No data found for  {cnr.english_name} ({cnr.entryid})")

    except pymysql.Error as e:
        print(f"Error: {e}")
        send_discord(f"Dumpr query failed {cnr.english_name}", VERBOSE)


###############################################################################################################
#
#  ███╗   ███╗ █████╗ ██╗███╗   ██╗
#  ████╗ ████║██╔══██╗██║████╗  ██║
#  ██╔████╔██║███████║██║██╔██╗ ██║
#  ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
#  ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
#  ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
#
###############################################################################################################


def main(
    storage_secrets_file=None,
    database_secrets_file=None,
    discord_secrets_file=None,
    codex_keywords=None,
):
    global webhooks
    global store

    webhooks = load_webhooks(discord_secrets_file)
    send_discord(
        f"Starting [Dumpr](<https://github.com/canonn-science/Dumpr/blob/main/README.md>)",
        VERBOSE,
    )
    print("Codex Keywords:", codex_keywords)
    db = connect_database(database_secrets_file)
    store = connect_storage(storage_secrets_file)

    # Getting a sorted list of codex entries
    entries = get_codex_list(db, store, webhooks, codex_keywords)
    for entry in entries:
        process_codex(db, entry)

    send_discord("Successful Dumpr", VERBOSE)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Process optional parameters.")
    parser.add_argument(
        "-s",
        "--storage_secrets",
        help="Storage Secrets File",
        default="storage_secrets.json",
    )
    parser.add_argument(
        "-d",
        "--database_secrets",
        help="Database Secrets File",
        default="database_secrets.json",
    )
    parser.add_argument(
        "-w",
        "--discord_secrets",
        help="Discord Secrets File",
        default="discord_secrets.json",
    )
    parser.add_argument("-c", "--codex_keywords", help="Codex Keywords", default=None)
    args = parser.parse_args()

    main(
        args.storage_secrets,
        args.database_secrets,
        args.discord_secrets,
        args.codex_keywords,
    )
